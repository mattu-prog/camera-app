<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<title>Camera OCR Judge (Improved)</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<style>
  body {
    margin: 0;
    background: black;
    overflow: hidden;
  }
  video, canvas {
    position: absolute;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
  }
  canvas {
    pointer-events: none;
  }
</style>
</head>

<body>

<video id="video" autoplay playsinline></video>
<canvas id="canvas"></canvas>

<script src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"></script>

<script>
const video = document.getElementById("video");
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");

let confirmedNumber = null;
let hitRank = null;

// OCR結果の履歴（多数決用）
let history = [];

// ---- カメラ起動 ----
async function startCamera() {
  const stream = await navigator.mediaDevices.getUserMedia({
    video: { facingMode: { ideal: "environment" } }
  });
  video.srcObject = stream;
}

video.addEventListener("loadedmetadata", () => {
  canvas.width = video.videoWidth;
  canvas.height = video.videoHeight;
  drawLoop();
  startOCRLoop();
});

// ---- 1秒に5回OCR ----
function startOCRLoop() {
  setInterval(async () => {
    const text = await readFromGuide();
    if (text) {
      history.push(text);
      if (history.length > 5) history.shift();
      confirmedNumber = majorityVote(history);
      hitRank = judgeNumber(confirmedNumber);
    }
  }, 200);
}

// ---- 多数決（3回以上一致） ----
function majorityVote(arr) {
  const count = {};
  arr.forEach(v => count[v] = (count[v] || 0) + 1);
  for (let k in count) {
    if (count[k] >= 3) return k;
  }
  return null;
}

// ---- 黄色枠内のみOCR（グレースケール） ----
async function readFromGuide() {
  // 横長ガイド（縦1：横4）
  const guideH = canvas.height * 0.12;
  const guideW = guideH * 4;
  const gx = (canvas.width - guideW) / 2;
  const gy = (canvas.height - guideH) / 2;

  const temp = document.createElement("canvas");
  temp.width = guideW;
  temp.height = guideH;
  const tctx = temp.getContext("2d");

  tctx.drawImage(video, gx, gy, guideW, guideH, 0, 0, guideW, guideH);

  // グレースケール変換のみ
  let img = tctx.getImageData(0, 0, guideW, guideH);
  for (let i = 0; i < img.data.length; i += 4) {
    let gray = (img.data[i] + img.data[i+1] + img.data[i+2]) / 3;
    img.data[i] = img.data[i+1] = img.data[i+2] = gray;
  }
  tctx.putImageData(img, 0, 0);

  const result = await Tesseract.recognize(temp, "eng", {
    tessedit_char_whitelist: "0123456789"
  });

  const text = result.data.text.replace(/\D/g, "");
  return text.length >= 2 ? text : null;
}

// ---- 判定ロジック（下2 → 下4 → 下6） ----
function judgeNumber(num) {
  if (!num) return null;

  if (["73","44","84"].includes(num.slice(-2))) return "三等";
  if (num.slice(-4) === "5037") return "二等";
  if (num.slice(-6) === "455756") return "一等";

  return null;
}

// ---- 描画 ----
function drawLoop() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // 外枠
  ctx.setLineDash([]);
  ctx.lineWidth = 10;
  ctx.strokeStyle = hitRank ? "lime" : "red";
  ctx.strokeRect(5, 5, canvas.width - 10, canvas.height - 10);

  // 黄色ガイド（横長）
  const guideH = canvas.height * 0.12;
  const guideW = guideH * 4;
  const gx = (canvas.width - guideW) / 2;
  const gy = (canvas.height - guideH) / 2;

  ctx.strokeStyle = "yellow";
  ctx.lineWidth = 4;
  ctx.setLineDash([15, 10]);
  ctx.strokeRect(gx, gy, guideW, guideH);

  // デバッグ表示（確認用）
  if (confirmedNumber) {
    ctx.setLineDash([]);
    ctx.fillStyle = "white";
    ctx.font = "28px monospace";
    ctx.fillText(confirmedNumber, 30, 40);
  }
  if (hitRank) {
    ctx.fillStyle = "lime";
    ctx.font = "40px sans-serif";
    ctx.fillText(hitRank, 30, 90);
  }

  requestAnimationFrame(drawLoop);
}

startCamera();
</script>

</body>
</html>
